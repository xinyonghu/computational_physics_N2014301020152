3.16
当t=2πn/D时，程序为
import matplotlib.pyplot as pl
import math
q=0.5
l=9.8
g=9.8
omega_d=float(2.0/3)


class nonlinear_pendulum():
    def __init__(self,_omega0=0,_theta0=0,_dt=0,_time=0,_Fd=0):
        self.omega0=_omega0
        self.theta0=_theta0
        self.dt=_dt
        self.time=_time
        self.Fd=_Fd
        
    def calculate(self):
        q=0.5
        l=9.8
        g=9.8
        omega_d=float(2.0/3)
        self.omega=[]
        self.theta=[]
        self.t=[]
        self.omega.append(self.omega0)
        self.theta.append(self.theta0)
        self.t.append(0)
        nsteps=int(self.time/self.dt)
        for i in range(1,nsteps):
            self.omega.append(self.omega[i-1]+(-g/l*math.sin(self.theta[i-1])-q*self.omega[i-1]+self.Fd*math.sin(omega_d*self.t[i-1]))*self.dt)
            self.theta.append(self.theta[i-1]+self.omega[i]*self.dt)
            self.t.append(self.t[i-1]+self.dt)
            if self.theta[i]<-math.pi:
                self.theta[i]=self.theta[i]+2*math.pi
            if self.theta[i]>math.pi:
                self.theta[i]=self.theta[i]-2*math.pi
        
        return 0
    def calculate_1(self):
        self.a=[]
        self.b=[]
        self.a.append(self.omega0)
        self.b.append(self.theta0)
        nsteps=int(self.time/self.dt)
        i=0        
        while i<nsteps:
            self.a.append(self.omega[i])
            self.b.append(self.theta[i])
            i=i+400
        return 0
           
           
            

        
    def plot_2D(self,color):
        pl.plot(self.t,self.theta,color,label="Fd=%r"%(self.Fd))
        pl.title("nonlinear pendulum")
        pl.xlabel("time(/s)")
        pl.ylabel("angle")
    def plot_phase(self,color):
        global nsteps
        pl.title("phase space")
        pl.xlabel("$\\theta$(radians)")
        pl.ylabel("$\\omega$(radians/s)")
        pl.scatter(self.theta,self.omega,s=1,label='Fd=%r'%(self.Fd))
    def plot_attractor(self):
        pl.scatter(self.b,self.a,s=2,label='$t=0.375n\\pi$')
        pl.title("phase space")
        pl.xlabel("$\\theta$(radians)")
        pl.ylabel("$\\omega$(radians/s)")

b=nonlinear_pendulum(0,0.2,0.375*math.pi/400,10000*math.pi,1.2)
b.calculate()
b.calculate_1()
b.plot_attractor()
pl.legend()
pl.show()  
当t=πn/2D时，程序为
import matplotlib.pyplot as pl
import math
q=0.5
l=9.8
g=9.8
omega_d=float(2.0/3)


class nonlinear_pendulum():
    def __init__(self,_omega0=0,_theta0=0,_dt=0,_time=0,_Fd=0):
        self.omega0=_omega0
        self.theta0=_theta0
        self.dt=_dt
        self.time=_time
        self.Fd=_Fd
        
    def calculate(self):
        q=0.5
        l=9.8
        g=9.8
        omega_d=float(2.0/3)
        self.omega=[]
        self.theta=[]
        self.t=[]
        self.omega.append(self.omega0)
        self.theta.append(self.theta0)
        self.t.append(0)
        nsteps=int(self.time/self.dt)
        for i in range(1,nsteps):
            self.omega.append(self.omega[i-1]+(-g/l*math.sin(self.theta[i-1])-q*self.omega[i-1]+self.Fd*math.sin(omega_d*self.t[i-1]))*self.dt)
            self.theta.append(self.theta[i-1]+self.omega[i]*self.dt)
            self.t.append(self.t[i-1]+self.dt)
            if self.theta[i]<-math.pi:
                self.theta[i]=self.theta[i]+2*math.pi
            if self.theta[i]>math.pi:
                self.theta[i]=self.theta[i]-2*math.pi
        
        return 0
    def calculate_1(self):
        self.a=[]
        self.b=[]
        self.a.append(self.omega0)
        self.b.append(self.theta0)
        nsteps=int(self.time/self.dt)
        i=0        
        while i<nsteps:
            self.a.append(self.omega[i])
            self.b.append(self.theta[i])
            i=i+400
        return 0
           
           
            

        
    def plot_2D(self,color):
        pl.plot(self.t,self.theta,color,label="Fd=%r"%(self.Fd))
        pl.title("nonlinear pendulum")
        pl.xlabel("time(/s)")
        pl.ylabel("angle")
    def plot_phase(self,color):
        global nsteps
        pl.title("phase space")
        pl.xlabel("$\\theta$(radians)")
        pl.ylabel("$\\omega$(radians/s)")
        pl.scatter(self.theta,self.omega,s=1,label='Fd=%r'%(self.Fd))
    def plot_attractor(self):
        pl.scatter(self.b,self.a,s=2,label='$t=0.375n\\pi$')
        pl.title("phase space")
        pl.xlabel("$\\theta$(radians)")
        pl.ylabel("$\\omega$(radians/s)")

b=nonlinear_pendulum(0,0.2,0.75*math.pi/800,20000*math.pi,1.2)
b.calculate()
b.calculate_1()
b.plot_attractor()
pl.legend()
pl.show()
当t=πn/4D时，程序为
import matplotlib.pyplot as pl
import math
q=0.5
l=9.8
g=9.8
omega_d=float(2.0/3)


class nonlinear_pendulum():
    def __init__(self,_omega0=0,_theta0=0,_dt=0,_time=0,_Fd=0):
        self.omega0=_omega0
        self.theta0=_theta0
        self.dt=_dt
        self.time=_time
        self.Fd=_Fd
        
    def calculate(self):
        q=0.5
        l=9.8
        g=9.8
        omega_d=float(2.0/3)
        self.omega=[]
        self.theta=[]
        self.t=[]
        self.omega.append(self.omega0)
        self.theta.append(self.theta0)
        self.t.append(0)
        nsteps=int(self.time/self.dt)
        for i in range(1,nsteps):
            self.omega.append(self.omega[i-1]+(-g/l*math.sin(self.theta[i-1])-q*self.omega[i-1]+self.Fd*math.sin(omega_d*self.t[i-1]))*self.dt)
            self.theta.append(self.theta[i-1]+self.omega[i]*self.dt)
            self.t.append(self.t[i-1]+self.dt)
            if self.theta[i]<-math.pi:
                self.theta[i]=self.theta[i]+2*math.pi
            if self.theta[i]>math.pi:
                self.theta[i]=self.theta[i]-2*math.pi
        
        return 0
    def calculate_1(self):
        self.a=[]
        self.b=[]
        self.a.append(self.omega0)
        self.b.append(self.theta0)
        nsteps=int(self.time/self.dt)
        i=0        
        while i<nsteps:
            self.a.append(self.omega[i])
            self.b.append(self.theta[i])
            i=i+400
        return 0
           
           
            

        
    def plot_2D(self,color):
        pl.plot(self.t,self.theta,color,label="Fd=%r"%(self.Fd))
        pl.title("nonlinear pendulum")
        pl.xlabel("time(/s)")
        pl.ylabel("angle")
    def plot_phase(self,color):
        global nsteps
        pl.title("phase space")
        pl.xlabel("$\\theta$(radians)")
        pl.ylabel("$\\omega$(radians/s)")
        pl.scatter(self.theta,self.omega,s=1,label='Fd=%r'%(self.Fd))
    def plot_attractor(self):
        pl.scatter(self.b,self.a,s=2,label='$t=0.375n\\pi$')
        pl.title("phase space")
        pl.xlabel("$\\theta$(radians)")
        pl.ylabel("$\\omega$(radians/s)")

b=nonlinear_pendulum(0,0.2,3*math.pi/800,20000*math.pi,1.2)
b.calculate()
b.calculate_1()
b.plot_attractor()
pl.legend()
pl.show()
比较三幅图可知，取不同的时间节点绘制出的图是不同的，具备一定的分形结构，在细节处的图像与图像的整体形貌是一致的。
